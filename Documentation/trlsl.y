// TRL Shader Language Lemon Grammar Rules


// Lemon Usage Notes:
//  Terminal/Nonterminal tokens
//      In Lemon, terminal and nonterminal symbols do not need to be declared or identified in a separate section
//      of the grammar file. Lemon is able to generate a list of all terminals and nonterminals by examining the grammar
//      rules, and it can always distinguish a terminal from a nonterminal by checking the case of the first character
//      of the name.
//  Example rule:
//        expr(A) ::= expr(B) PLUS expr(C).  { A = B+C; }
//  Precedence:
//      Lemon allows a measure of control over the resolution of parsing conflicts using precedence rules. A
//      precedence value can be assigned to any terminal symbol using the %left, %right or %nonassoc directives.
//      Terminal symbols mentioned in earlier directives have a lower precedence than terminal symbols mentioned
//      in later directives. See more from the doc.
//
//  Directives:
//      %code: is used to specify additional C code that is added to the end of the main output file.
//      %include: at the beginning of the main output file:
//          %include {#include <unisted.h>}
//      %default_type: The %default_type directive specifies the data type of non-terminal symbols that do not
//              have their own data type defined using a separate %type directive.
//      %destructor: used to specify a destructor for a non-terminal symbol.
//      %name:  default, the functions generated by Lemon all begin with the five-character string "Parse".
//          You can change this string to something different using the %name directive.
//      %parse_failure: The %parse_failure directive specifies a block of C code that is executed whenever
//          the parser fails complete.
//      %token_type: These directives are used to specify the data types for values on the parser's stack
//          associated with terminal and non-terminal symbols. 
//          Example: %token_type {Token*}
//      %type: Non-terminal symbols can each have their own data types.
//          Example: %type expr {Expr*}



%name TrlSLParser_  // Functions in generated code all begins with this string.
%token_prefix T_
%token_type {Token*}

%include {
    struct Token
    {
        Token()
            :
            Type(0), StrLen(0), Str(nullptr)
        {}

        unsigned int Type;
        unsigned int StrLen;
        const char* Str;
    };
}

// Copied a lot from GLSL ES Specification, Chapter 10. Shading Language Grammar.
// https://www.khronos.org/registry/OpenGL/specs/es/3.2/GLSL_ES_Specification_3.20.pdf


%start_symbol translation_unit


variable_identifier ::= IDENTIFIER.

primary_expression ::= variable_identifier.
primary_expression ::= INTCONSTANT.
primary_expression ::= UINTCONSTANT.
primary_expression ::= FLOATCONSTANT.
primary_expression ::= BOOLCONSTANT.
primary_expression ::= LS expression RS.

postfix_expression ::= primary_expression.
postfix_expression ::= postfix_expression LM integer_expression RM.
postfix_expression ::= function_call.
postfix_expression ::= postfix_expression DOT FIELD_SELECTION.
postfix_expression ::= postfix_expression INC_OP.
postfix_expression ::= postfix_expression DEC_OP.
    // FIELD_SELECTION includes fields in structures, component selection for vectors
    // and the 'length' identifier for the length() method

integer_expression ::= expression.

function_call ::= function_call_or_method.

function_call_or_method ::= function_call_generic.

function_call_generic ::= function_call_header_with_parameters RS.
function_call_generic ::= function_call_header_no_parameters RS.

function_call_header_no_parameters ::= function_call_header VOID.
function_call_header_no_parameters ::= function_call_header.

function_call_header_with_parameters ::= function_call_header assignment_expression.
function_call_header_with_parameters ::= function_call_header_with_parameters COMMA assignment_expression.

function_call_header ::= function_identifier LS.

    // Grammar Note: Constructors look like functions, but lexical analysis recognized most of them as
    // keywords. They are now recognized through “type_specifier”.
    // Methods (.length) and identifiers are recognized through postfix_expression.

function_identifier ::= type_specifier.
function_identifier ::= postfix_expression.

unary_expression ::= postfix_expression.
unary_expression ::= INC_OP unary_expression.
unary_expression ::= DEC_OP unary_expression.
unary_expression ::= unary_operator unary_expression.
    // Grammar Note: No traditional style type casts.

unary_operator ::= PLUS. // +
unary_operator ::= DASH. // -
unary_operator ::= BANG. // !
unary_operator ::= TILDE. // ~
    // Grammar Note: No '*' or '&' unary ops. Pointers are not supported.

multiplicative_expression ::= unary_expression.
multiplicative_expression ::= multiplicative_expression STAR unary_expression. // *
multiplicative_expression ::= multiplicative_expression SLASH unary_expression. // /
multiplicative_expression ::= multiplicative_expression PERCENT unary_expression. // %

additive_expression ::= multiplicative_expression.
additive_expression ::= additive_expression PLUS multiplicative_expression.
additive_expression ::= additive_expression DASH multiplicative_expression.

shift_expression ::= additive_expression.
shift_expression ::= shift_expression LEFT_OP additive_expression.
shift_expression ::= shift_expression RIGHT_OP additive_expression.

relational_expression ::= shift_expression.
relational_expression ::= relational_expression LEFT_ANGLE shift_expression.
relational_expression ::= relational_expression RIGHT_ANGLE shift_expression.
relational_expression ::= relational_expression LE_OP shift_expression.
relational_expression ::= relational_expression GE_OP shift_expression.

equality_expression ::= relational_expression.
equality_expression ::= equality_expression EQ_OP relational_expression.
equality_expression ::= equality_expression NE_OP relational_expression.

and_expression ::= equality_expression.
and_expression ::= and_expression AMPERSAND equality_expression.

exclusive_or_expression ::= and_expression.
exclusive_or_expression ::= exclusive_or_expression CARET and_expression. // ^

inclusive_or_expression ::= exclusive_or_expression.
inclusive_or_expression ::= inclusive_or_expression VERTICAL_BAR exclusive_or_expression. // |

logical_and_expression ::= inclusive_or_expression.
logical_and_expression ::= logical_and_expression AND_OP inclusive_or_expression.

logical_or_expression ::= logical_and_expression.
logical_or_expression ::= logical_or_expression OR_OP logical_and_expression.

conditional_expression ::= logical_or_expression.
conditional_expression ::= logical_or_expression QUESTION expression COLON assignment_expression.

assignment_expression ::= conditional_expression.
assignment_expression ::= unary_expression assignment_operator assignment_expression.

assignment_operator ::= EQUAL. // =
assignment_operator ::= MUL_ASSIGN.
assignment_operator ::= DIV_ASSIGN.
assignment_operator ::= MOD_ASSIGN. // %=
assignment_operator ::= ADD_ASSIGN.
assignment_operator ::= SUB_ASSIGN.
assignment_operator ::= LEFT_ASSIGN. // <<=
assignment_operator ::= RIGHT_ASSIGN. // >>=
assignment_operator ::= AND_ASSIGN. // &=
assignment_operator ::= XOR_ASSIGN. // ^=
assignment_operator ::= OR_ASSIGN. // |=

expression ::= assignment_expression.
expression ::= expression COMMA assignment_expression.

constant_expression ::= conditional_expression.

declaration ::= init_declarator_list SEMICOLON.

identifier_list ::= COMMA IDENTIFIER.
identifier_list ::= identifier_list COMMA IDENTIFIER.

function_prototype ::= function_declarator RS.

function_declarator ::= function_header.
function_declarator ::= function_header_with_parameters.

function_header_with_parameters ::= function_header parameter_declaration.
function_header_with_parameters ::= function_header_with_parameters COMMA parameter_declaration.

function_header ::= fully_specified_type IDENTIFIER LS.

parameter_declarator ::= type_specifier IDENTIFIER.
parameter_declarator ::= type_specifier IDENTIFIER array_specifier.

parameter_declaration ::= type_qualifier parameter_declarator.
parameter_declaration ::= parameter_declarator.
parameter_declaration ::= type_qualifier parameter_type_specifier.
parameter_declaration ::= parameter_type_specifier.

parameter_type_specifier ::= type_specifier.

init_declarator_list ::= single_declaration.
init_declarator_list ::= init_declarator_list COMMA IDENTIFIER.
init_declarator_list ::= init_declarator_list COMMA IDENTIFIER array_specifier.
init_declarator_list ::= init_declarator_list COMMA IDENTIFIER array_specifier EQUAL initializer.
init_declarator_list ::= init_declarator_list COMMA IDENTIFIER EQUAL initializer.

single_declaration ::= fully_specified_type.
single_declaration ::= fully_specified_type IDENTIFIER.
single_declaration ::= fully_specified_type IDENTIFIER array_specifier.
single_declaration ::= fully_specified_type IDENTIFIER array_specifier EQUAL initializer.
single_declaration ::= fully_specified_type IDENTIFIER EQUAL initializer.

fully_specified_type ::= type_specifier.
fully_specified_type ::= type_qualifier type_specifier.

type_qualifier ::= single_type_qualifier.
type_qualifier ::= type_qualifier single_type_qualifier.

single_type_qualifier ::= storage_qualifier.
single_type_qualifier ::= precision_qualifier.

storage_qualifier ::= CONST.
storage_qualifier ::= IN.
storage_qualifier ::= OUT.
storage_qualifier ::= INOUT.
storage_qualifier ::= UNIFORM.

type_specifier ::= type_specifier_nonarray.
type_specifier ::= type_specifier_nonarray array_specifier.

array_specifier ::= LM RM.
array_specifier ::= LM constant_expression RM.
array_specifier ::= array_specifier LM RM.
array_specifier ::= array_specifier LM constant_expression RM.

type_specifier_nonarray ::= VOID.
type_specifier_nonarray ::= FLOAT.
type_specifier_nonarray ::= INT.
type_specifier_nonarray ::= UINT.
type_specifier_nonarray ::= BOOL.
type_specifier_nonarray ::= VEC2.
type_specifier_nonarray ::= VEC3.
type_specifier_nonarray ::= VEC4.
type_specifier_nonarray ::= BVEC2.
type_specifier_nonarray ::= BVEC3.
type_specifier_nonarray ::= BVEC4.
type_specifier_nonarray ::= IVEC2.
type_specifier_nonarray ::= IVEC3.
type_specifier_nonarray ::= IVEC4.
type_specifier_nonarray ::= UVEC2.
type_specifier_nonarray ::= UVEC3.
type_specifier_nonarray ::= UVEC4.
type_specifier_nonarray ::= MAT2.
type_specifier_nonarray ::= MAT3.
type_specifier_nonarray ::= MAT4.
type_specifier_nonarray ::= MAT2X2.
type_specifier_nonarray ::= MAT2X3.
type_specifier_nonarray ::= MAT2X4.
type_specifier_nonarray ::= MAT3X2.
type_specifier_nonarray ::= MAT3X3.
type_specifier_nonarray ::= MAT3X4.
type_specifier_nonarray ::= MAT4X2.
type_specifier_nonarray ::= MAT4X3.
type_specifier_nonarray ::= MAT4X4.
type_specifier_nonarray ::= SAMPLER2D.
type_specifier_nonarray ::= SAMPLER3D.
type_specifier_nonarray ::= SAMPLERCUBE.

precision_qualifier ::= HIGH_PRECISION.
precision_qualifier ::= MEDIUM_PRECISION.
precision_qualifier ::= LOW_PRECISION.

initializer ::= assignment_expression.

declaration_statement ::= declaration.

statement ::= compound_statement.
statement ::= simple_statement.

simple_statement ::= declaration_statement.
simple_statement ::= expression_statement.
simple_statement ::= selection_statement.
simple_statement ::= iteration_statement.
simple_statement ::= jump_statement.

compound_statement ::= LEFT_BRACE RIGHT_BRACE.
compound_statement ::= LEFT_BRACE statement_list RIGHT_BRACE.

statement_list ::= statement.
statement_list ::= statement_list statement.

expression_statement ::= SEMICOLON.
expression_statement ::= expression SEMICOLON.

selection_statement ::= IF LEFT_PAREN expression RIGHT_PAREN selection_rest_statement.

selection_rest_statement ::= statement ELSE statement.
selection_rest_statement ::= statement.

condition ::= expression.
condition ::= fully_specified_type IDENTIFIER EQUAL initializer.

iteration_statement ::= WHILE LEFT_PAREN condition RIGHT_PAREN statement.
iteration_statement ::= FOR LEFT_PAREN for_init_statement for_rest_statement RIGHT_PAREN.
iteration_statement ::= statement.

for_init_statement ::= expression_statement.
for_init_statement ::= declaration_statement.

condition_opt ::= condition.
condition_opt ::= /* empty */.

for_rest_statement ::= condition_opt SEMICOLON.
for_rest_statement ::= condition_opt SEMICOLON expression.

jump_statement ::= CONTINUE SEMICOLON.
jump_statement ::= BREAK SEMICOLON.
jump_statement ::= RETURN SEMICOLON.
jump_statement ::= RETURN expression SEMICOLON.
jump_statement ::= DISCARD SEMICOLON SEMICOLON. // Fragment shader only.

translation_unit ::= external_declaration.
translation_unit ::= translation_unit external_declaration.

external_declaration ::= function_definition.
external_declaration ::= declaration.

function_definition ::= function_prototype compound_statement.
